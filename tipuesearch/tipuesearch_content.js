var tipuesearch = {"pages":[{"title":" ForUnitTest ","text":"ForUnitTest Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"unit_test â€“ ForUnitTest ","text":"type, public :: unit_test Components Type Visibility Attributes Name Initial character(len=38), public :: msg Type-Bound Procedures procedure, private :: print_msg private  subroutine print_msg (this, condition) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in) :: condition procedure, private :: unit_test_r0 private  subroutine unit_test_r0 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in) :: res real(kind=rk), intent(in) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg procedure, private :: unit_test_r1 private  subroutine unit_test_r1 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: res real(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg procedure, private :: unit_test_r2 private  subroutine unit_test_r2 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in), dimension(:,:) :: res real(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg procedure, private :: unit_test_i0 private  subroutine unit_test_i0 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in) :: res integer(kind=ik), intent(in) :: expected character(len=*), intent(in), optional :: msg procedure, private :: unit_test_i1 private  subroutine unit_test_i1 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: res integer(kind=ik), intent(in), dimension(:) :: expected character(len=*), intent(in), optional :: msg procedure, private :: unit_test_i2 private  subroutine unit_test_i2 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:,:) :: res integer(kind=ik), intent(in), dimension(:,:) :: expected character(len=*), intent(in), optional :: msg procedure, private :: unit_test_l0 private  subroutine unit_test_l0 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in) :: res logical, intent(in) :: expected character(len=*), intent(in), optional :: msg procedure, private :: unit_test_l1 private  subroutine unit_test_l1 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in), dimension(:) :: res logical, intent(in), dimension(:) :: expected character(len=*), intent(in), optional :: msg procedure, private :: unit_test_l2 private  subroutine unit_test_l2 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in), dimension(:,:) :: res logical, intent(in), dimension(:,:) :: expected character(len=*), intent(in), optional :: msg procedure, private :: unit_test_cx0 private  subroutine unit_test_cx0 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in) :: res complex(kind=rk), intent(in) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg procedure, private :: unit_test_cx1 private  subroutine unit_test_cx1 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: res complex(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg procedure, private :: unit_test_cx2 private  subroutine unit_test_cx2 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:,:) :: res complex(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg generic, public :: check => unit_test_r0 , unit_test_r1 , unit_test_r2 , unit_test_i0 , unit_test_i1 , unit_test_i2 , unit_test_l0 , unit_test_l1 , unit_test_l2 , unit_test_cx0 , unit_test_cx1 , unit_test_cx2 private  subroutine unit_test_r0 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in) :: res real(kind=rk), intent(in) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg private  subroutine unit_test_r1 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: res real(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg private  subroutine unit_test_r2 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in), dimension(:,:) :: res real(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg private  subroutine unit_test_i0 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in) :: res integer(kind=ik), intent(in) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_i1 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: res integer(kind=ik), intent(in), dimension(:) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_i2 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:,:) :: res integer(kind=ik), intent(in), dimension(:,:) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_l0 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in) :: res logical, intent(in) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_l1 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in), dimension(:) :: res logical, intent(in), dimension(:) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_l2 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in), dimension(:,:) :: res logical, intent(in), dimension(:,:) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_cx0 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in) :: res complex(kind=rk), intent(in) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg private  subroutine unit_test_cx1 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: res complex(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg private  subroutine unit_test_cx2 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:,:) :: res complex(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg Source Code type unit_test character ( len = 38 ) :: msg contains procedure , private :: print_msg procedure , private :: unit_test_r0 procedure , private :: unit_test_r1 procedure , private :: unit_test_r2 procedure , private :: unit_test_i0 procedure , private :: unit_test_i1 procedure , private :: unit_test_i2 procedure , private :: unit_test_l0 procedure , private :: unit_test_l1 procedure , private :: unit_test_l2 procedure , private :: unit_test_cx0 procedure , private :: unit_test_cx1 procedure , private :: unit_test_cx2 generic :: check => unit_test_r0 , unit_test_r1 , unit_test_r2 , & unit_test_i0 , unit_test_i1 , unit_test_i2 , & unit_test_l0 , unit_test_l1 , unit_test_l2 , & unit_test_cx0 , unit_test_cx1 , unit_test_cx2 end type unit_test","tags":"","loc":"type/unit_test.html"},{"title":"print_msg â€“ ForUnitTest","text":"private  subroutine print_msg(this, condition) Uses face proc~~print_msg~~UsesGraph proc~print_msg forunittest::unit_test%print_msg face face proc~print_msg->face Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in) :: condition Calls proc~~print_msg~~CallsGraph proc~print_msg forunittest::unit_test%print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_msg~~CalledByGraph proc~print_msg forunittest::unit_test%print_msg proc~unit_test_cx0 forunittest::unit_test%unit_test_cx0 proc~unit_test_cx0->proc~print_msg proc~unit_test_cx1 forunittest::unit_test%unit_test_cx1 proc~unit_test_cx1->proc~print_msg proc~unit_test_cx2 forunittest::unit_test%unit_test_cx2 proc~unit_test_cx2->proc~print_msg proc~unit_test_i0 forunittest::unit_test%unit_test_i0 proc~unit_test_i0->proc~print_msg proc~unit_test_i1 forunittest::unit_test%unit_test_i1 proc~unit_test_i1->proc~print_msg proc~unit_test_i2 forunittest::unit_test%unit_test_i2 proc~unit_test_i2->proc~print_msg proc~unit_test_l0 forunittest::unit_test%unit_test_l0 proc~unit_test_l0->proc~print_msg proc~unit_test_l1 forunittest::unit_test%unit_test_l1 proc~unit_test_l1->proc~print_msg proc~unit_test_l2 forunittest::unit_test%unit_test_l2 proc~unit_test_l2->proc~print_msg proc~unit_test_r0 forunittest::unit_test%unit_test_r0 proc~unit_test_r0->proc~print_msg proc~unit_test_r1 forunittest::unit_test%unit_test_r1 proc~unit_test_r1->proc~print_msg proc~unit_test_r2 forunittest::unit_test%unit_test_r2 proc~unit_test_r2->proc~print_msg none~check forunittest::unit_test%check none~check->proc~unit_test_cx0 none~check->proc~unit_test_cx1 none~check->proc~unit_test_cx2 none~check->proc~unit_test_i0 none~check->proc~unit_test_i1 none~check->proc~unit_test_i2 none~check->proc~unit_test_l0 none~check->proc~unit_test_l1 none~check->proc~unit_test_l2 none~check->proc~unit_test_r0 none~check->proc~unit_test_r1 none~check->proc~unit_test_r2 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine print_msg ( this , condition ) use face class ( unit_test ), intent ( inout ) :: this logical , intent ( in ) :: condition integer :: lm character ( len = 20 ) :: fmt lm = 39 - len_trim ( this % msg ) write ( fmt , '(a,g0,a)' ) '(a,' , lm , 'x,a)' if ( condition ) then print ( fmt ), trim ( this % msg ), colorize ( 'passed.' , color_fg = 'green' ) else print ( fmt ), trim ( this % msg ), colorize ( 'failed.' , color_fg = 'red' ) end if end subroutine print_msg","tags":"","loc":"proc/print_msg.html"},{"title":"unit_test_r0 â€“ ForUnitTest","text":"private  subroutine unit_test_r0(this, res, expected, tol, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in) :: res real(kind=rk), intent(in) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg Calls proc~~unit_test_r0~~CallsGraph proc~unit_test_r0 forunittest::unit_test%unit_test_r0 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_r0->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_r0~~CalledByGraph proc~unit_test_r0 forunittest::unit_test%unit_test_r0 none~check forunittest::unit_test%check none~check->proc~unit_test_r0 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_r0 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this real ( rk ), intent ( in ) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( abs ( expected ) < tiny ( 0.0_rk )) then rel_err = abs ( res - expected ) else rel_err = abs ( res - expected ) / abs ( expected ) end if if ( present ( tol )) then condition = rel_err < tol else condition = rel_err == 0.0_rk end if call this % print_msg ( condition ) end subroutine unit_test_r0","tags":"","loc":"proc/unit_test_r0.html"},{"title":"unit_test_r1 â€“ ForUnitTest","text":"private  subroutine unit_test_r1(this, res, expected, tol, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: res real(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg Calls proc~~unit_test_r1~~CallsGraph proc~unit_test_r1 forunittest::unit_test%unit_test_r1 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_r1->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_r1~~CalledByGraph proc~unit_test_r1 forunittest::unit_test%unit_test_r1 none~check forunittest::unit_test%check none~check->proc~unit_test_r1 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_r1 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this real ( rk ), intent ( in ), dimension (:) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( norm2 ( expected ) < tiny ( 0.0_rk )) then rel_err = norm2 ( res - expected ) else rel_err = norm2 ( res - expected ) / norm2 ( expected ) end if if ( present ( tol )) then condition = rel_err < tol else condition = rel_err == 0.0_rk end if call this % print_msg ( condition ) end subroutine unit_test_r1","tags":"","loc":"proc/unit_test_r1.html"},{"title":"unit_test_r2 â€“ ForUnitTest","text":"private  subroutine unit_test_r2(this, res, expected, tol, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in), dimension(:,:) :: res real(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg Calls proc~~unit_test_r2~~CallsGraph proc~unit_test_r2 forunittest::unit_test%unit_test_r2 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_r2->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_r2~~CalledByGraph proc~unit_test_r2 forunittest::unit_test%unit_test_r2 none~check forunittest::unit_test%check none~check->proc~unit_test_r2 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_r2 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this real ( rk ), intent ( in ), dimension (:,:) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( norm2 ( expected ) < tiny ( 0.0_rk )) then rel_err = norm2 ( res - expected ) else rel_err = norm2 ( res - expected ) / norm2 ( expected ) end if if ( present ( tol )) then condition = rel_err < tol else condition = rel_err == 0.0_rk end if call this % print_msg ( condition ) end subroutine unit_test_r2","tags":"","loc":"proc/unit_test_r2.html"},{"title":"unit_test_i0 â€“ ForUnitTest","text":"private  subroutine unit_test_i0(this, res, expected, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in) :: res integer(kind=ik), intent(in) :: expected character(len=*), intent(in), optional :: msg Calls proc~~unit_test_i0~~CallsGraph proc~unit_test_i0 forunittest::unit_test%unit_test_i0 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_i0->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_i0~~CalledByGraph proc~unit_test_i0 forunittest::unit_test%unit_test_i0 none~check forunittest::unit_test%check none~check->proc~unit_test_i0 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_i0 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this integer ( ik ), intent ( in ) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = res == expected call this % print_msg ( condition ) end subroutine unit_test_i0","tags":"","loc":"proc/unit_test_i0.html"},{"title":"unit_test_i1 â€“ ForUnitTest","text":"private  subroutine unit_test_i1(this, res, expected, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: res integer(kind=ik), intent(in), dimension(:) :: expected character(len=*), intent(in), optional :: msg Calls proc~~unit_test_i1~~CallsGraph proc~unit_test_i1 forunittest::unit_test%unit_test_i1 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_i1->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_i1~~CalledByGraph proc~unit_test_i1 forunittest::unit_test%unit_test_i1 none~check forunittest::unit_test%check none~check->proc~unit_test_i1 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_i1 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this integer ( ik ), intent ( in ), dimension (:) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = all ( res == expected ) call this % print_msg ( condition ) end subroutine unit_test_i1","tags":"","loc":"proc/unit_test_i1.html"},{"title":"unit_test_i2 â€“ ForUnitTest","text":"private  subroutine unit_test_i2(this, res, expected, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:,:) :: res integer(kind=ik), intent(in), dimension(:,:) :: expected character(len=*), intent(in), optional :: msg Calls proc~~unit_test_i2~~CallsGraph proc~unit_test_i2 forunittest::unit_test%unit_test_i2 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_i2->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_i2~~CalledByGraph proc~unit_test_i2 forunittest::unit_test%unit_test_i2 none~check forunittest::unit_test%check none~check->proc~unit_test_i2 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_i2 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this integer ( ik ), intent ( in ), dimension (:,:) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = all ( res == expected ) call this % print_msg ( condition ) end subroutine unit_test_i2","tags":"","loc":"proc/unit_test_i2.html"},{"title":"unit_test_l0 â€“ ForUnitTest","text":"private  subroutine unit_test_l0(this, res, expected, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in) :: res logical, intent(in) :: expected character(len=*), intent(in), optional :: msg Calls proc~~unit_test_l0~~CallsGraph proc~unit_test_l0 forunittest::unit_test%unit_test_l0 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_l0->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_l0~~CalledByGraph proc~unit_test_l0 forunittest::unit_test%unit_test_l0 none~check forunittest::unit_test%check none~check->proc~unit_test_l0 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_l0 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this logical , intent ( in ) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = res . eqv . expected call this % print_msg ( condition ) end subroutine unit_test_l0","tags":"","loc":"proc/unit_test_l0.html"},{"title":"unit_test_l1 â€“ ForUnitTest","text":"private  subroutine unit_test_l1(this, res, expected, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in), dimension(:) :: res logical, intent(in), dimension(:) :: expected character(len=*), intent(in), optional :: msg Calls proc~~unit_test_l1~~CallsGraph proc~unit_test_l1 forunittest::unit_test%unit_test_l1 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_l1->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_l1~~CalledByGraph proc~unit_test_l1 forunittest::unit_test%unit_test_l1 none~check forunittest::unit_test%check none~check->proc~unit_test_l1 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_l1 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this logical , intent ( in ), dimension (:) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = all ( res . eqv . expected ) call this % print_msg ( condition ) end subroutine unit_test_l1","tags":"","loc":"proc/unit_test_l1.html"},{"title":"unit_test_l2 â€“ ForUnitTest","text":"private  subroutine unit_test_l2(this, res, expected, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in), dimension(:,:) :: res logical, intent(in), dimension(:,:) :: expected character(len=*), intent(in), optional :: msg Calls proc~~unit_test_l2~~CallsGraph proc~unit_test_l2 forunittest::unit_test%unit_test_l2 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_l2->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_l2~~CalledByGraph proc~unit_test_l2 forunittest::unit_test%unit_test_l2 none~check forunittest::unit_test%check none~check->proc~unit_test_l2 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_l2 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this logical , intent ( in ), dimension (:,:) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = all ( res . eqv . expected ) call this % print_msg ( condition ) end subroutine unit_test_l2","tags":"","loc":"proc/unit_test_l2.html"},{"title":"unit_test_cx0 â€“ ForUnitTest","text":"private  subroutine unit_test_cx0(this, res, expected, tol, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in) :: res complex(kind=rk), intent(in) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg Calls proc~~unit_test_cx0~~CallsGraph proc~unit_test_cx0 forunittest::unit_test%unit_test_cx0 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_cx0->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_cx0~~CalledByGraph proc~unit_test_cx0 forunittest::unit_test%unit_test_cx0 none~check forunittest::unit_test%check none~check->proc~unit_test_cx0 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_cx0 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( abs ( expected ) < tiny ( 0.0_rk )) then rel_err = abs ( res - expected ) else rel_err = abs ( res - expected ) / abs ( expected ) end if if ( present ( tol )) then condition = rel_err < tol else condition = rel_err == 0.0_rk end if call this % print_msg ( condition ) end subroutine unit_test_cx0","tags":"","loc":"proc/unit_test_cx0.html"},{"title":"unit_test_cx1 â€“ ForUnitTest","text":"private  subroutine unit_test_cx1(this, res, expected, tol, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: res complex(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg Calls proc~~unit_test_cx1~~CallsGraph proc~unit_test_cx1 forunittest::unit_test%unit_test_cx1 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_cx1->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_cx1~~CalledByGraph proc~unit_test_cx1 forunittest::unit_test%unit_test_cx1 none~check forunittest::unit_test%check none~check->proc~unit_test_cx1 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_cx1 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this complex ( rk ), intent ( in ), dimension (:) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err_re , rel_err_im if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( norm2 ( expected % re ) < tiny ( 0.0_rk )) then rel_err_re = norm2 ( res % re - expected % re ) else rel_err_re = norm2 ( res % re - expected % re ) / norm2 ( expected % re ) end if if ( norm2 ( expected % im ) < tiny ( 0.0_rk )) then rel_err_im = norm2 ( res % im - expected % im ) else rel_err_im = norm2 ( res % im - expected % im ) / norm2 ( expected % im ) end if if ( present ( tol )) then condition = ( rel_err_re < tol ) . and . ( rel_err_im < tol ) else condition = ( rel_err_re <= tiny ( 0.0_rk )) . and . ( rel_err_im <= tiny ( 0.0_rk )) end if call this % print_msg ( condition ) end subroutine unit_test_cx1","tags":"","loc":"proc/unit_test_cx1.html"},{"title":"unit_test_cx2 â€“ ForUnitTest","text":"private  subroutine unit_test_cx2(this, res, expected, tol, msg) Type Bound unit_test Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:,:) :: res complex(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg Calls proc~~unit_test_cx2~~CallsGraph proc~unit_test_cx2 forunittest::unit_test%unit_test_cx2 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_cx2->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit_test_cx2~~CalledByGraph proc~unit_test_cx2 forunittest::unit_test%unit_test_cx2 none~check forunittest::unit_test%check none~check->proc~unit_test_cx2 program~demo demo program~demo->none~check program~test test program~test->none~check Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine unit_test_cx2 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this complex ( rk ), intent ( in ), dimension (:,:) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err_re , rel_err_im if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( norm2 ( expected % re ) < tiny ( 0.0_rk )) then rel_err_re = norm2 ( res % re - expected % re ) else rel_err_re = norm2 ( res % re - expected % re ) / norm2 ( expected % re ) end if if ( norm2 ( expected % im ) < tiny ( 0.0_rk )) then rel_err_im = norm2 ( res % im - expected % im ) else rel_err_im = norm2 ( res % im - expected % im ) / norm2 ( expected % im ) end if if ( present ( tol )) then condition = ( rel_err_re < tol ) . and . ( rel_err_im < tol ) else condition = ( rel_err_re <= tiny ( 0.0_rk )) . and . ( rel_err_im <= tiny ( 0.0_rk )) end if call this % print_msg ( condition ) end subroutine unit_test_cx2","tags":"","loc":"proc/unit_test_cx2.html"},{"title":"forunittest â€“ ForUnitTest","text":"Uses kinds module~~forunittest~~UsesGraph module~forunittest forunittest kinds kinds module~forunittest->kinds Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forunittest~~UsedByGraph module~forunittest forunittest program~demo demo program~demo->module~forunittest program~test test program~test->module~forunittest Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, publicÂ :: unit_test Components Type Visibility Attributes Name Initial character(len=38), public :: msg Type-Bound Procedures procedure, private :: print_msg procedure, private :: unit_test_r0 procedure, private :: unit_test_r1 procedure, private :: unit_test_r2 procedure, private :: unit_test_i0 procedure, private :: unit_test_i1 procedure, private :: unit_test_i2 procedure, private :: unit_test_l0 procedure, private :: unit_test_l1 procedure, private :: unit_test_l2 procedure, private :: unit_test_cx0 procedure, private :: unit_test_cx1 procedure, private :: unit_test_cx2 generic, public :: check => unit_test_r0 , unit_test_r1 , unit_test_r2 , unit_test_i0 , unit_test_i1 , unit_test_i2 , unit_test_l0 , unit_test_l1 , unit_test_l2 , unit_test_cx0 , unit_test_cx1 , unit_test_cx2 Subroutines private  subroutine print_msg (this, condition) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in) :: condition private  subroutine unit_test_r0 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in) :: res real(kind=rk), intent(in) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg private  subroutine unit_test_r1 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in), dimension(:) :: res real(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg private  subroutine unit_test_r2 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this real(kind=rk), intent(in), dimension(:,:) :: res real(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg private  subroutine unit_test_i0 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in) :: res integer(kind=ik), intent(in) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_i1 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:) :: res integer(kind=ik), intent(in), dimension(:) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_i2 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:,:) :: res integer(kind=ik), intent(in), dimension(:,:) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_l0 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in) :: res logical, intent(in) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_l1 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in), dimension(:) :: res logical, intent(in), dimension(:) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_l2 (this, res, expected, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this logical, intent(in), dimension(:,:) :: res logical, intent(in), dimension(:,:) :: expected character(len=*), intent(in), optional :: msg private  subroutine unit_test_cx0 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in) :: res complex(kind=rk), intent(in) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg private  subroutine unit_test_cx1 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:) :: res complex(kind=rk), intent(in), dimension(:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg private  subroutine unit_test_cx2 (this, res, expected, tol, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( unit_test ), intent(inout) :: this complex(kind=rk), intent(in), dimension(:,:) :: res complex(kind=rk), intent(in), dimension(:,:) :: expected real(kind=rk), intent(in), optional :: tol character(len=*), intent(in), optional :: msg","tags":"","loc":"module/forunittest.html"},{"title":"demo â€“ ForUnitTest","text":"Uses forunittest kinds program~~demo~~UsesGraph program~demo demo kinds kinds program~demo->kinds module~forunittest forunittest program~demo->module~forunittest module~forunittest->kinds Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~demo~~CallsGraph program~demo demo none~check forunittest::unit_test%check program~demo->none~check proc~unit_test_cx0 forunittest::unit_test%unit_test_cx0 none~check->proc~unit_test_cx0 proc~unit_test_cx1 forunittest::unit_test%unit_test_cx1 none~check->proc~unit_test_cx1 proc~unit_test_cx2 forunittest::unit_test%unit_test_cx2 none~check->proc~unit_test_cx2 proc~unit_test_i0 forunittest::unit_test%unit_test_i0 none~check->proc~unit_test_i0 proc~unit_test_i1 forunittest::unit_test%unit_test_i1 none~check->proc~unit_test_i1 proc~unit_test_i2 forunittest::unit_test%unit_test_i2 none~check->proc~unit_test_i2 proc~unit_test_l0 forunittest::unit_test%unit_test_l0 none~check->proc~unit_test_l0 proc~unit_test_l1 forunittest::unit_test%unit_test_l1 none~check->proc~unit_test_l1 proc~unit_test_l2 forunittest::unit_test%unit_test_l2 none~check->proc~unit_test_l2 proc~unit_test_r0 forunittest::unit_test%unit_test_r0 none~check->proc~unit_test_r0 proc~unit_test_r1 forunittest::unit_test%unit_test_r1 none~check->proc~unit_test_r1 proc~unit_test_r2 forunittest::unit_test%unit_test_r2 none~check->proc~unit_test_r2 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_cx0->proc~print_msg proc~unit_test_cx1->proc~print_msg proc~unit_test_cx2->proc~print_msg proc~unit_test_i0->proc~print_msg proc~unit_test_i1->proc~print_msg proc~unit_test_i2->proc~print_msg proc~unit_test_l0->proc~print_msg proc~unit_test_l1->proc~print_msg proc~unit_test_l2->proc~print_msg proc~unit_test_r0->proc~print_msg proc~unit_test_r1->proc~print_msg proc~unit_test_r2->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( unit_test ) :: ut Source Code program demo ! Include module for data type definitions use kinds ! Use 'forunittest' module to access the unit_test type use forunittest , only : unit_test implicit none ! Declare an object of type 'unit_test' type ( unit_test ) :: ut ! call ut%check(res, expected, tol, msg) ! Variables 'res' and 'expected' can be of types: real(rk), integer(ik), logical, or complex(rk) ! Their ranks can be 0, 1, or 2 ! 'tol' is an optional real(rk) parameter, default value is 'tiny(0.0_rk)' ! 'msg' is an optional character parameter, default value is 'forunittest' ! Note: 'res' and 'expected' must have the same type and shape call ut % check ( res = 1.0_rk , expected = 1.0_rk , tol = 1e-5_rk , msg = \"demo test 1\" ) ! 'tol' is optional call ut % check ( res = 2.0_rk , expected = 1.0_rk , tol = 1e-5_rk , msg = \"demo test 2\" ) ! 'tol' is optional end program demo","tags":"","loc":"program/demo.html"},{"title":"test â€“ ForUnitTest","text":"Uses forunittest kinds program~~test~~UsesGraph program~test test kinds kinds program~test->kinds module~forunittest forunittest program~test->module~forunittest module~forunittest->kinds Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. real(rk) rank 0, without tol\nreal(rk) rank 1\nreal(rk) rank 1, without tol\nreal(rk) rank 2\nreal(rk) rank 2, without tol\ninteger(ik) rank 0\ninteger(ik) rank 1\ninteger(ik) rank 2\nlogical rank 0\nlogical rank 1\nlogical rank 2\ncomplex(rk) rank 0\ncomplex(rk) rank 0, without tol\ncomplex(rk) rank 1\ncomplex(rk) rank 1, without tol\ncomplex(rk) rank 2\ncomplex(rk) rank 2, without tol Calls program~~test~~CallsGraph program~test test none~check forunittest::unit_test%check program~test->none~check proc~unit_test_cx0 forunittest::unit_test%unit_test_cx0 none~check->proc~unit_test_cx0 proc~unit_test_cx1 forunittest::unit_test%unit_test_cx1 none~check->proc~unit_test_cx1 proc~unit_test_cx2 forunittest::unit_test%unit_test_cx2 none~check->proc~unit_test_cx2 proc~unit_test_i0 forunittest::unit_test%unit_test_i0 none~check->proc~unit_test_i0 proc~unit_test_i1 forunittest::unit_test%unit_test_i1 none~check->proc~unit_test_i1 proc~unit_test_i2 forunittest::unit_test%unit_test_i2 none~check->proc~unit_test_i2 proc~unit_test_l0 forunittest::unit_test%unit_test_l0 none~check->proc~unit_test_l0 proc~unit_test_l1 forunittest::unit_test%unit_test_l1 none~check->proc~unit_test_l1 proc~unit_test_l2 forunittest::unit_test%unit_test_l2 none~check->proc~unit_test_l2 proc~unit_test_r0 forunittest::unit_test%unit_test_r0 none~check->proc~unit_test_r0 proc~unit_test_r1 forunittest::unit_test%unit_test_r1 none~check->proc~unit_test_r1 proc~unit_test_r2 forunittest::unit_test%unit_test_r2 none~check->proc~unit_test_r2 proc~print_msg forunittest::unit_test%print_msg proc~unit_test_cx0->proc~print_msg proc~unit_test_cx1->proc~print_msg proc~unit_test_cx2->proc~print_msg proc~unit_test_i0->proc~print_msg proc~unit_test_i1->proc~print_msg proc~unit_test_i2->proc~print_msg proc~unit_test_l0->proc~print_msg proc~unit_test_l1->proc~print_msg proc~unit_test_l2->proc~print_msg proc~unit_test_r0->proc~print_msg proc~unit_test_r1->proc~print_msg proc~unit_test_r2->proc~print_msg colorize colorize proc~print_msg->colorize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( unit_test ) :: ut real(rk) rank 0 Source Code program test use kinds use forunittest implicit none type ( unit_test ) :: ut !! real(rk) rank 0 call ut % check ( res = 1.0_rk , expected = 1.0_rk , tol = 1e-5_rk , msg = \"test 1 passed\" ) ! tol is optional call ut % check ( res = 2.0_rk , expected = 1.0_rk , tol = 1e-5_rk , msg = \"test 1 failed\" ) ! tol is optional !! real(rk) rank 0, without tol call ut % check ( res = 1.0_rk , expected = 1.0_rk , msg = \"test 2 passed\" ) call ut % check ( res = 2.0_rk , expected = 1.0_rk , msg = \"test 2 failed\" ) !! real(rk) rank 1 call ut % check ( res = [ 1.0_rk , 2.0_rk ], expected = [ 1.0_rk , 2.0_rk ], tol = 1e-5_rk , msg = \"test 3 passed\" ) ! tol is optional call ut % check ( res = [ 1.0_rk , 1.0_rk ], expected = [ 1.0_rk , 2.0_rk ], tol = 1e-5_rk , msg = \"test 3 failed\" ) ! tol is optional call ut % check ( res = [ 2.0_rk , 1.0_rk ], expected = [ 1.0_rk , 2.0_rk ], tol = 1e-5_rk , msg = \"test 3 failed\" ) ! tol is optional !! real(rk) rank 1, without tol call ut % check ( res = [ 1.0_rk , 2.0_rk ], expected = [ 1.0_rk , 2.0_rk ], msg = \"test 4 passed\" ) call ut % check ( res = [ 1.0_rk , 1.0_rk ], expected = [ 1.0_rk , 2.0_rk ], msg = \"test 4 failed\" ) call ut % check ( res = [ 2.0_rk , 1.0_rk ], expected = [ 1.0_rk , 2.0_rk ], msg = \"test 4 failed\" ) !! real(rk) rank 2 call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 5 passed\" ) ! tol is optional call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 5.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 5 failed\" ) ! tol is optional call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 4.0_rk , 3.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 5 failed\" ) ! tol is optional !! real(rk) rank 2, without tol call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& msg = \"test 6 passed\" ) ! tol is optional call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 5.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& msg = \"test 6 failed\" ) ! tol is optional call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 4.0_rk , 3.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& msg = \"test 6 failed\" ) ! tol is optional !! integer(ik) rank 0 call ut % check ( res = 1_ik , expected = 1_ik , msg = \"test 7 passed\" ) call ut % check ( res = 2_ik , expected = 1_ik , msg = \"test 7 failed\" ) !! integer(ik) rank 1 call ut % check ( res = [ 1 , 2 ], expected = [ 1 , 2 ], msg = \"test 8 passed\" ) call ut % check ( res = [ 1 , 3 ], expected = [ 1 , 2 ], msg = \"test 8 failed\" ) call ut % check ( res = [ 2 , 1 ], expected = [ 1 , 2 ], msg = \"test 8 failed\" ) !! integer(ik) rank 2 call ut % check ( res = reshape ([ 1_ik , 2_ik , 3_ik , 4_ik ], [ 2 , 2 ]),& expected = reshape ([ 1_ik , 2_ik , 3_ik , 4_ik ], [ 2 , 2 ]),& msg = \"test 9 passed\" ) call ut % check ( res = reshape ([ 1_ik , 2_ik , 3_ik , 5_ik ], [ 2 , 2 ]),& expected = reshape ([ 1_ik , 2_ik , 3_ik , 4_ik ], [ 2 , 2 ]),& msg = \"test 9 failed\" ) call ut % check ( res = reshape ([ 1_ik , 2_ik , 4_ik , 3_ik ], [ 2 , 2 ]),& expected = reshape ([ 1_ik , 2_ik , 3_ik , 4_ik ], [ 2 , 2 ]),& msg = \"test 9 failed\" ) !! logical rank 0 call ut % check ( res = . true ., expected = . true ., msg = \"test 10 passed\" ) call ut % check ( res = . false ., expected = . true ., msg = \"test 10 failed\" ) !! logical rank 1 call ut % check ( res = [. true .,. false .], expected = [. true .,. false .], msg = \"test 11 passed\" ) call ut % check ( res = [. true .,. true .], expected = [. true .,. false .], msg = \"test 11 failed\" ) call ut % check ( res = [. false .,. true .], expected = [. true .,. false .], msg = \"test 11 failed\" ) !! logical rank 2 call ut % check ( res = reshape ([. true .,. true .,. false .,. false .], [ 2 , 2 ]),& expected = reshape ([. true .,. true .,. false .,. false .], [ 2 , 2 ]),& msg = \"test 12 passed\" ) call ut % check ( res = reshape ([. true .,. true .,. false .,. false .], [ 2 , 2 ]),& expected = reshape ([. true .,. false .,. false .,. false .], [ 2 , 2 ]),& msg = \"test 12 failed\" ) call ut % check ( res = reshape ([. true .,. true .,. false .,. false .], [ 2 , 2 ]),& expected = reshape ([. true .,. false .,. true .,. false .], [ 2 , 2 ]),& msg = \"test 12 failed\" ) !! complex(rk) rank 0 call ut % check ( res = ( 1.0_rk , 1.0_rk ), expected = ( 1.0_rk , 1.0_rk ), tol = 1e-5_rk , msg = \"test 13 passed\" ) ! tol is optional call ut % check ( res = ( 2.0_rk , 1.0_rk ), expected = ( 1.0_rk , 1.0_rk ), tol = 1e-5_rk , msg = \"test 13 failed\" ) ! tol is optional call ut % check ( res = ( 1.0_rk , 2.0_rk ), expected = ( 1.0_rk , 1.0_rk ), tol = 1e-5_rk , msg = \"test 13 failed\" ) ! tol is optional !! complex(rk) rank 0, without tol call ut % check ( res = ( 1.0_rk , 1.0_rk ), expected = ( 1.0_rk , 1.0_rk ), msg = \"test 14 passed\" ) call ut % check ( res = ( 2.0_rk , 1.0_rk ), expected = ( 1.0_rk , 1.0_rk ), msg = \"test 14 failed\" ) call ut % check ( res = ( 1.0_rk , 2.0_rk ), expected = ( 1.0_rk , 1.0_rk ), msg = \"test 14 failed\" ) !! complex(rk) rank 1 call ut % check ( res = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )],& expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], tol = 1e-5_rk ,& msg = \"test 15 passed\" ) ! tol is optional call ut % check ( res = [( 2.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )],& expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], tol = 1e-5_rk ,& msg = \"test 15 failed\" ) ! tol is optional call ut % check ( res = [( 2.0_rk , 2.0_rk ),( 1.0_rk , 1.0_rk )],& expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], tol = 1e-5_rk ,& msg = \"test 15 failed\" ) ! tol is optional !! complex(rk) rank 1, without tol call ut % check ( res = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], msg = \"test 16 passed\" ) call ut % check ( res = [( 2.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], msg = \"test 16 failed\" ) call ut % check ( res = [( 2.0_rk , 2.0_rk ),( 1.0_rk , 1.0_rk )], expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], msg = \"test 16 failed\" ) !! complex(rk) rank 2 call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 17 passed\" ) call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 5.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 17 failed\" ) call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 4.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 17 failed\" ) !! complex(rk) rank 2, without tol call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& msg = \"test 18 passed\" ) call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 5.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& msg = \"test 18 failed\" ) call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 4.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& msg = \"test 18 failed\" ) end program test","tags":"","loc":"program/test.html"},{"title":"forunittest.f90 â€“ ForUnitTest","text":"Files dependent on this one sourcefile~~forunittest.f90~~AfferentGraph sourcefile~forunittest.f90 forunittest.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forunittest.f90 sourcefile~test.f90 test.f90 sourcefile~test.f90->sourcefile~forunittest.f90 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forunittest use kinds implicit none private public unit_test !=============================================================================== !> author: Seyed Ali Ghasemi type unit_test character ( len = 38 ) :: msg contains procedure , private :: print_msg procedure , private :: unit_test_r0 procedure , private :: unit_test_r1 procedure , private :: unit_test_r2 procedure , private :: unit_test_i0 procedure , private :: unit_test_i1 procedure , private :: unit_test_i2 procedure , private :: unit_test_l0 procedure , private :: unit_test_l1 procedure , private :: unit_test_l2 procedure , private :: unit_test_cx0 procedure , private :: unit_test_cx1 procedure , private :: unit_test_cx2 generic :: check => unit_test_r0 , unit_test_r1 , unit_test_r2 , & unit_test_i0 , unit_test_i1 , unit_test_i2 , & unit_test_l0 , unit_test_l1 , unit_test_l2 , & unit_test_cx0 , unit_test_cx1 , unit_test_cx2 end type unit_test !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi subroutine print_msg ( this , condition ) use face class ( unit_test ), intent ( inout ) :: this logical , intent ( in ) :: condition integer :: lm character ( len = 20 ) :: fmt lm = 39 - len_trim ( this % msg ) write ( fmt , '(a,g0,a)' ) '(a,' , lm , 'x,a)' if ( condition ) then print ( fmt ), trim ( this % msg ), colorize ( 'passed.' , color_fg = 'green' ) else print ( fmt ), trim ( this % msg ), colorize ( 'failed.' , color_fg = 'red' ) end if end subroutine print_msg !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_r0 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this real ( rk ), intent ( in ) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( abs ( expected ) < tiny ( 0.0_rk )) then rel_err = abs ( res - expected ) else rel_err = abs ( res - expected ) / abs ( expected ) end if if ( present ( tol )) then condition = rel_err < tol else condition = rel_err == 0.0_rk end if call this % print_msg ( condition ) end subroutine unit_test_r0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_r1 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this real ( rk ), intent ( in ), dimension (:) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( norm2 ( expected ) < tiny ( 0.0_rk )) then rel_err = norm2 ( res - expected ) else rel_err = norm2 ( res - expected ) / norm2 ( expected ) end if if ( present ( tol )) then condition = rel_err < tol else condition = rel_err == 0.0_rk end if call this % print_msg ( condition ) end subroutine unit_test_r1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_r2 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this real ( rk ), intent ( in ), dimension (:,:) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( norm2 ( expected ) < tiny ( 0.0_rk )) then rel_err = norm2 ( res - expected ) else rel_err = norm2 ( res - expected ) / norm2 ( expected ) end if if ( present ( tol )) then condition = rel_err < tol else condition = rel_err == 0.0_rk end if call this % print_msg ( condition ) end subroutine unit_test_r2 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_i0 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this integer ( ik ), intent ( in ) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = res == expected call this % print_msg ( condition ) end subroutine unit_test_i0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_i1 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this integer ( ik ), intent ( in ), dimension (:) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = all ( res == expected ) call this % print_msg ( condition ) end subroutine unit_test_i1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_i2 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this integer ( ik ), intent ( in ), dimension (:,:) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = all ( res == expected ) call this % print_msg ( condition ) end subroutine unit_test_i2 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_l0 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this logical , intent ( in ) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = res . eqv . expected call this % print_msg ( condition ) end subroutine unit_test_l0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_l1 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this logical , intent ( in ), dimension (:) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = all ( res . eqv . expected ) call this % print_msg ( condition ) end subroutine unit_test_l1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_l2 ( this , res , expected , msg ) class ( unit_test ), intent ( inout ) :: this logical , intent ( in ), dimension (:,:) :: res , expected character ( * ), intent ( in ), optional :: msg logical :: condition if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if condition = all ( res . eqv . expected ) call this % print_msg ( condition ) end subroutine unit_test_l2 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_cx0 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this complex ( rk ), intent ( in ) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( abs ( expected ) < tiny ( 0.0_rk )) then rel_err = abs ( res - expected ) else rel_err = abs ( res - expected ) / abs ( expected ) end if if ( present ( tol )) then condition = rel_err < tol else condition = rel_err == 0.0_rk end if call this % print_msg ( condition ) end subroutine unit_test_cx0 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_cx1 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this complex ( rk ), intent ( in ), dimension (:) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err_re , rel_err_im if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( norm2 ( expected % re ) < tiny ( 0.0_rk )) then rel_err_re = norm2 ( res % re - expected % re ) else rel_err_re = norm2 ( res % re - expected % re ) / norm2 ( expected % re ) end if if ( norm2 ( expected % im ) < tiny ( 0.0_rk )) then rel_err_im = norm2 ( res % im - expected % im ) else rel_err_im = norm2 ( res % im - expected % im ) / norm2 ( expected % im ) end if if ( present ( tol )) then condition = ( rel_err_re < tol ) . and . ( rel_err_im < tol ) else condition = ( rel_err_re <= tiny ( 0.0_rk )) . and . ( rel_err_im <= tiny ( 0.0_rk )) end if call this % print_msg ( condition ) end subroutine unit_test_cx1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine unit_test_cx2 ( this , res , expected , tol , msg ) class ( unit_test ), intent ( inout ) :: this complex ( rk ), intent ( in ), dimension (:,:) :: res , expected real ( rk ), intent ( in ), optional :: tol character ( * ), intent ( in ), optional :: msg logical :: condition real ( rk ) :: rel_err_re , rel_err_im if ( present ( msg )) then this % msg = msg else this % msg = 'forunittest' end if if ( norm2 ( expected % re ) < tiny ( 0.0_rk )) then rel_err_re = norm2 ( res % re - expected % re ) else rel_err_re = norm2 ( res % re - expected % re ) / norm2 ( expected % re ) end if if ( norm2 ( expected % im ) < tiny ( 0.0_rk )) then rel_err_im = norm2 ( res % im - expected % im ) else rel_err_im = norm2 ( res % im - expected % im ) / norm2 ( expected % im ) end if if ( present ( tol )) then condition = ( rel_err_re < tol ) . and . ( rel_err_im < tol ) else condition = ( rel_err_re <= tiny ( 0.0_rk )) . and . ( rel_err_im <= tiny ( 0.0_rk )) end if call this % print_msg ( condition ) end subroutine unit_test_cx2 !=============================================================================== end module forunittest","tags":"","loc":"sourcefile/forunittest.f90.html"},{"title":"demo.f90 â€“ ForUnitTest","text":"This file depends on sourcefile~~demo.f90~~EfferentGraph sourcefile~demo.f90 demo.f90 sourcefile~forunittest.f90 forunittest.f90 sourcefile~demo.f90->sourcefile~forunittest.f90 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program demo ! Include module for data type definitions use kinds ! Use 'forunittest' module to access the unit_test type use forunittest , only : unit_test implicit none ! Declare an object of type 'unit_test' type ( unit_test ) :: ut ! call ut%check(res, expected, tol, msg) ! Variables 'res' and 'expected' can be of types: real(rk), integer(ik), logical, or complex(rk) ! Their ranks can be 0, 1, or 2 ! 'tol' is an optional real(rk) parameter, default value is 'tiny(0.0_rk)' ! 'msg' is an optional character parameter, default value is 'forunittest' ! Note: 'res' and 'expected' must have the same type and shape call ut % check ( res = 1.0_rk , expected = 1.0_rk , tol = 1e-5_rk , msg = \"demo test 1\" ) ! 'tol' is optional call ut % check ( res = 2.0_rk , expected = 1.0_rk , tol = 1e-5_rk , msg = \"demo test 2\" ) ! 'tol' is optional end program demo","tags":"","loc":"sourcefile/demo.f90.html"},{"title":"test.f90 â€“ ForUnitTest","text":"This file depends on sourcefile~~test.f90~~EfferentGraph sourcefile~test.f90 test.f90 sourcefile~forunittest.f90 forunittest.f90 sourcefile~test.f90->sourcefile~forunittest.f90 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test use kinds use forunittest implicit none type ( unit_test ) :: ut !! real(rk) rank 0 call ut % check ( res = 1.0_rk , expected = 1.0_rk , tol = 1e-5_rk , msg = \"test 1 passed\" ) ! tol is optional call ut % check ( res = 2.0_rk , expected = 1.0_rk , tol = 1e-5_rk , msg = \"test 1 failed\" ) ! tol is optional !! real(rk) rank 0, without tol call ut % check ( res = 1.0_rk , expected = 1.0_rk , msg = \"test 2 passed\" ) call ut % check ( res = 2.0_rk , expected = 1.0_rk , msg = \"test 2 failed\" ) !! real(rk) rank 1 call ut % check ( res = [ 1.0_rk , 2.0_rk ], expected = [ 1.0_rk , 2.0_rk ], tol = 1e-5_rk , msg = \"test 3 passed\" ) ! tol is optional call ut % check ( res = [ 1.0_rk , 1.0_rk ], expected = [ 1.0_rk , 2.0_rk ], tol = 1e-5_rk , msg = \"test 3 failed\" ) ! tol is optional call ut % check ( res = [ 2.0_rk , 1.0_rk ], expected = [ 1.0_rk , 2.0_rk ], tol = 1e-5_rk , msg = \"test 3 failed\" ) ! tol is optional !! real(rk) rank 1, without tol call ut % check ( res = [ 1.0_rk , 2.0_rk ], expected = [ 1.0_rk , 2.0_rk ], msg = \"test 4 passed\" ) call ut % check ( res = [ 1.0_rk , 1.0_rk ], expected = [ 1.0_rk , 2.0_rk ], msg = \"test 4 failed\" ) call ut % check ( res = [ 2.0_rk , 1.0_rk ], expected = [ 1.0_rk , 2.0_rk ], msg = \"test 4 failed\" ) !! real(rk) rank 2 call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 5 passed\" ) ! tol is optional call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 5.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 5 failed\" ) ! tol is optional call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 4.0_rk , 3.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 5 failed\" ) ! tol is optional !! real(rk) rank 2, without tol call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& msg = \"test 6 passed\" ) ! tol is optional call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 5.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& msg = \"test 6 failed\" ) ! tol is optional call ut % check ( res = reshape ([ 1.0_rk , 2.0_rk , 4.0_rk , 3.0_rk ], [ 2 , 2 ]),& expected = reshape ([ 1.0_rk , 2.0_rk , 3.0_rk , 4.0_rk ], [ 2 , 2 ]),& msg = \"test 6 failed\" ) ! tol is optional !! integer(ik) rank 0 call ut % check ( res = 1_ik , expected = 1_ik , msg = \"test 7 passed\" ) call ut % check ( res = 2_ik , expected = 1_ik , msg = \"test 7 failed\" ) !! integer(ik) rank 1 call ut % check ( res = [ 1 , 2 ], expected = [ 1 , 2 ], msg = \"test 8 passed\" ) call ut % check ( res = [ 1 , 3 ], expected = [ 1 , 2 ], msg = \"test 8 failed\" ) call ut % check ( res = [ 2 , 1 ], expected = [ 1 , 2 ], msg = \"test 8 failed\" ) !! integer(ik) rank 2 call ut % check ( res = reshape ([ 1_ik , 2_ik , 3_ik , 4_ik ], [ 2 , 2 ]),& expected = reshape ([ 1_ik , 2_ik , 3_ik , 4_ik ], [ 2 , 2 ]),& msg = \"test 9 passed\" ) call ut % check ( res = reshape ([ 1_ik , 2_ik , 3_ik , 5_ik ], [ 2 , 2 ]),& expected = reshape ([ 1_ik , 2_ik , 3_ik , 4_ik ], [ 2 , 2 ]),& msg = \"test 9 failed\" ) call ut % check ( res = reshape ([ 1_ik , 2_ik , 4_ik , 3_ik ], [ 2 , 2 ]),& expected = reshape ([ 1_ik , 2_ik , 3_ik , 4_ik ], [ 2 , 2 ]),& msg = \"test 9 failed\" ) !! logical rank 0 call ut % check ( res = . true ., expected = . true ., msg = \"test 10 passed\" ) call ut % check ( res = . false ., expected = . true ., msg = \"test 10 failed\" ) !! logical rank 1 call ut % check ( res = [. true .,. false .], expected = [. true .,. false .], msg = \"test 11 passed\" ) call ut % check ( res = [. true .,. true .], expected = [. true .,. false .], msg = \"test 11 failed\" ) call ut % check ( res = [. false .,. true .], expected = [. true .,. false .], msg = \"test 11 failed\" ) !! logical rank 2 call ut % check ( res = reshape ([. true .,. true .,. false .,. false .], [ 2 , 2 ]),& expected = reshape ([. true .,. true .,. false .,. false .], [ 2 , 2 ]),& msg = \"test 12 passed\" ) call ut % check ( res = reshape ([. true .,. true .,. false .,. false .], [ 2 , 2 ]),& expected = reshape ([. true .,. false .,. false .,. false .], [ 2 , 2 ]),& msg = \"test 12 failed\" ) call ut % check ( res = reshape ([. true .,. true .,. false .,. false .], [ 2 , 2 ]),& expected = reshape ([. true .,. false .,. true .,. false .], [ 2 , 2 ]),& msg = \"test 12 failed\" ) !! complex(rk) rank 0 call ut % check ( res = ( 1.0_rk , 1.0_rk ), expected = ( 1.0_rk , 1.0_rk ), tol = 1e-5_rk , msg = \"test 13 passed\" ) ! tol is optional call ut % check ( res = ( 2.0_rk , 1.0_rk ), expected = ( 1.0_rk , 1.0_rk ), tol = 1e-5_rk , msg = \"test 13 failed\" ) ! tol is optional call ut % check ( res = ( 1.0_rk , 2.0_rk ), expected = ( 1.0_rk , 1.0_rk ), tol = 1e-5_rk , msg = \"test 13 failed\" ) ! tol is optional !! complex(rk) rank 0, without tol call ut % check ( res = ( 1.0_rk , 1.0_rk ), expected = ( 1.0_rk , 1.0_rk ), msg = \"test 14 passed\" ) call ut % check ( res = ( 2.0_rk , 1.0_rk ), expected = ( 1.0_rk , 1.0_rk ), msg = \"test 14 failed\" ) call ut % check ( res = ( 1.0_rk , 2.0_rk ), expected = ( 1.0_rk , 1.0_rk ), msg = \"test 14 failed\" ) !! complex(rk) rank 1 call ut % check ( res = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )],& expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], tol = 1e-5_rk ,& msg = \"test 15 passed\" ) ! tol is optional call ut % check ( res = [( 2.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )],& expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], tol = 1e-5_rk ,& msg = \"test 15 failed\" ) ! tol is optional call ut % check ( res = [( 2.0_rk , 2.0_rk ),( 1.0_rk , 1.0_rk )],& expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], tol = 1e-5_rk ,& msg = \"test 15 failed\" ) ! tol is optional !! complex(rk) rank 1, without tol call ut % check ( res = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], msg = \"test 16 passed\" ) call ut % check ( res = [( 2.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], msg = \"test 16 failed\" ) call ut % check ( res = [( 2.0_rk , 2.0_rk ),( 1.0_rk , 1.0_rk )], expected = [( 1.0_rk , 1.0_rk ),( 2.0_rk , 2.0_rk )], msg = \"test 16 failed\" ) !! complex(rk) rank 2 call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 17 passed\" ) call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 5.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 17 failed\" ) call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 4.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& tol = 1e-5_rk , msg = \"test 17 failed\" ) !! complex(rk) rank 2, without tol call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& msg = \"test 18 passed\" ) call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 5.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& msg = \"test 18 failed\" ) call ut % check ( res = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 4.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& expected = reshape ([( 1.0_rk , 1.0_rk ), ( 2.0_rk , 2.0_rk ), ( 3.0_rk , 3.0_rk ), ( 4.0_rk , 4.0_rk )], [ 2 , 2 ]),& msg = \"test 18 failed\" ) end program test","tags":"","loc":"sourcefile/test.f90.html"}]}